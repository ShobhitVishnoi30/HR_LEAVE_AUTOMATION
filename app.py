from document_utils.chat_with_hr import get_reply_normally
from gmail_utils.email_fetching import run_cron
from document_utils.extract_text_and_create_chunks import (
    extract_and_save_pdf_attachment,
)
from custom_expection import CustomParametersException
from flask import Flask, request, jsonify, Response
from flask_cors import CORS
from apscheduler.schedulers.background import BackgroundScheduler
from flasgger import Swagger
import atexit
from config import cron_time_in_minutes
import os
from slack_utils import get_user_profile, send_slack_message
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
from flask import Flask, request, jsonify
from slackeventsapi import SlackEventAdapter


# set configuration values
app = Flask(__name__)

cors = CORS(app)
app.config["SWAGGER"] = {"title": "HR", "uiversion": 3}
swagger = Swagger(app)

slack_client = WebClient(
    token="SLACK_TOKEN"
)

slack_events_adapter = SlackEventAdapter("SLACK_TOKEN", "/slack/events", app)

challenge_value = None


@app.route("/insert_data", methods=["POST"])
def insert_data():
    """
    Insert Data Endpoint

    This endpoint allows users to insert data from a PDF link into a specified namespace in Pinecone.

    ---
    tags:
    - Insert Data

    parameters:
    - in: body
      name: body
      required: true
      schema:
        type: object
        properties:
          namespace:
            type: string
            description: The namespace to insert the data into.
            required: true
          pdf_link:
            type: string
            description: The S3 link to the PDF file.
            required: true

    responses:
      200:
        description: Successful response containing the inserted data IDs.
        schema:
          type: object
          properties:
            status:
              type: boolean
              description: True if the data was inserted successfully, False otherwise.
            message:
              type: string
              description: A message describing the result of the operation.
            data:
              type: array
              items:
                type: string
              description: An array of IDs for the inserted data in Pinecone.

      400:
        description: field cannot be empty.

      500:
        description: Internal Server Error.
    """
    try:
        # Get S3 link from request body
        data = request.json

        for field in ["namespace", "pdf_link"]:
            if not data.get(field):
                raise CustomParametersException(field + "cannot be empty", code=400)

        namespace = data.get("namespace")
        s3_link = data.get("pdf_link")
        pinecone_ids = extract_and_save_pdf_attachment(s3_link, namespace)
        # Return parsed emails in the response

        response = {
            "status": True,
            "message": "Data inserted successfully",
            "data": pinecone_ids,
        }
        return jsonify(response), 200

    except Exception as e:
        response = {
            "status": False,
            "message": "Data not inserted",
            "data": [],
        }
        return jsonify(response), 500


@app.route("/query", methods=["GET"])
def handle_query():
    """
    Query Character Endpoint

    This endpoint allows users to query a specific character or persona and receive a response generated by the specified language model (LLM).

    ---
    tags:
    - Query Character

    parameters:
    - in: query
      name: namespace
      required: true
      type: string
      description: The namespace of the character or persona.

    - in: query
      name: query
      required: true
      type: string
      description: The query or prompt for the character or persona.

    - in: query
      name: LLM
      required: true
      type: string
      description: The language model to use for generating the response.
      enum: [openai, mistral, groq, claude]

    responses:
      200:
        description: Successful response containing the generated reply.
        schema:
          type: object
          properties:
            status:
              type: boolean
              description: True if the query was successful, False otherwise.
            message:
              type: string
              description: A message describing the result of the operation.
            reply:
              type: string
              description: The generated reply from the character or persona.

      400:
        description: Bad request. Missing required parameters.
        schema:
          type: object
          properties:
            status:
              type: boolean
              value: false
            message:
              type: string
              description: An error message explaining the missing parameters.

      500:
        description: Internal Server Error.
        schema:
          type: object
          properties:
            status:
              type: boolean
              value: false
            message:
              type: string
              description: An error message describing the internal server error.
    """
    try:

        # Getting parameters from the query string
        namespace = request.args.get("namespace")
        query = request.args.get("query")
        LLM = request.args.get("LLM")
        if not all([namespace, query, LLM]):
            raise CustomParametersException(
                "All parameters (namespace, query, LLM) are required", code=400
            )

        response_generator = get_reply_normally(query, namespace, LLM)
        # def generate():
        #     with app.app_context():
        #         for response in response_generator:
        #             print(response)
        #             json_str = json.dumps({"response": response})
        #             yield json_str.encode()
        # return Response(generate(), mimetype="application/json")

        response = {
            "status": True,
            "message": "query fetched",
            "reply": response_generator,
        }
        return jsonify(response), 200
    except Exception as exc:
        response = {
            "status": False,
            "message": str(exc),
            "reply": "",
        }
        return jsonify(response), 500


@app.route("/slack/event", methods=["POST"])
def hello1():
    # Access JSON data from the request
    data = request.json

    print(data)

    event = data.get("event")
    # if event:
    #     print("Event  text is ", event.get("text"))
    #     print("Event  user is ", event.get("user"))
    #     profile = get_user_profile(event.get("user"))
    #     print("Profile", profile)
    #     # print(find_user_id_by_email(profile.get("email")))
    #     # members_emails = ["sv@gmail.com", "hy@gmail.com"]
    #     # create_group_channel(members_emails)

    challenge = data.get("challenge")
    global challenge_value
    if challenge:
        challenge_value = challenge

    return challenge_value


@app.route("/send_message", methods=["POST"])
def send_message():
    data = request.get_json()
    if "email" in data and "message" in data:
        email = data["email"]
        message = data["message"]
        send_slack_message(email, message)
        return jsonify({"status": "Message sent successfully"}), 200
    else:
        return jsonify({"error": "Email and message are required fields"}), 400


@slack_events_adapter.on("message")
def message(payload):
    return


if __name__ == "__main__":
    # Schedule background tasks using the BackgroundScheduler
    scheduler = BackgroundScheduler(daemon=True)
    # Schedule the 'upcoming_event_main' function to run every minute
    scheduler.add_job(func=run_cron, trigger="interval", seconds=10)
    scheduler.start()

    # Shut down the scheduler when exiting the app
    atexit.register(lambda: scheduler.shutdown())
    app.run("0.0.0.0", port=5001)
